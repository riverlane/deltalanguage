..
  Notes for developers:

  All ``py`` and ``ipynb`` files from this directory are evaluated by the
  test suite and treated as integration tests.

  Please make sure that each file is referred in this tutorial and
  has at least a simple ``assert`` statement that confirms the correctness.

  Before committing any changes ``ipynb`` files, restart the Jupyter kernel
  and re-run all the cells from top to bottom.


Tutorials
=========

Below we present tutorials to help users get a grip on the Deltaflow language.
While we do recommend going through these in the specified order, once
familiar with the Basics users may read just the examples relevant to
what they need.

Quick start
-----------

`Quick Start <quick_start.html>`_
(:download:`quick_start.ipynb`)
is a tutorial designed to overview main components of the language
and show the workflow in case of designing program in Deltalanguage.
This tuturial can be skipped and revised at any point of time af a refresher.

Main tutorial
-------------

Deltaflow programming language is based of the paradigm of `dataflow
programming <https://en.wikipedia.org/wiki/Dataflow_programming>`_.
It means that a Deltaflow program is a
collection of asynchronous processes (handled by nodes) which can
exchange data via directional channels (handled by input and output ports of
nodes).
By design such a program *must* be robust to any delays of individual processes
execution as well as data transfer.
Each program has a formal exiting strategy by obtaining a desirable result.
On the other hand if a Deltaflow program is non-deterministic then the exit
conditions must allow for non-determinism.

Basics
^^^^^^

- :py:class:`DeltaGraph<deltalanguage.wiring.DeltaGraph>` is the central part of
  the Deltaflow language and consists of a collection of nodes connected
  with each other via directional links representing data channels.
  Please check out the examples section of this class.

  .. image:: ../../docs/figs/graph.png
    :width: 600

- Nodes are containers for computing processes. There are different types of
  nodes that are best suited for different tasks.
  In short, these nodes can be generated by the following python decorators,
  please check out the examples section for each of them:

  - :py:class:`DeltaBlock<deltalanguage.wiring.DeltaBlock>` decorator
    is the main
    element of the Deltaflow language that allow users to define stateless
    nodes, i.e. the output of such nodes is fully determined by inputs.

  - :py:class:`DeltaMethodBlock<deltalanguage.wiring.DeltaMethodBlock>`
    decorator that defines a node with a state, which along with inputs
    determine the output.

  - :py:class:`Interactive<deltalanguage.wiring.Interactive>` decorator
    allows the user to define its rules as well as a state.

  .. image:: ../../docs/figs/blocks.png
    :width: 600

- :py:class:`DeltaPySimulator<deltalanguage.runtime.DeltaPySimulator>` is the
  Python Simulator that comes along with the Deltaflow language and used
  for debugging and proof-of-principle evaluations of the graph.
  This simulator supports only python and migen nodes.
  Please check out the examples section of this class.

  .. image:: ../../docs/figs/running.png
    :width: 600

- `Deltaflow Data Types <data_types.html>`_
  (:download:`data_types.ipynb`) overviews the Deltaflow data
  types and rules of communication between nodes in general.


Wiring techniques
^^^^^^^^^^^^^^^^^

This section overviews various intricacies of connecting a complex graph:

- Use
  :py:func:`make_forked_return<deltalanguage.data_types.make_forked_return>`
  to send split output of a node to multiple channels.
  Please check out the examples section of this class.
  `Outputting to Multiple Destinations <multiple_destinations.html>`_
  (:download:`multiple_destinations.ipynb`)
  will cover this topic in more detail.
  
- Use
  :py:func:`placeholder_node_factory<deltalanguage.wiring.placeholder_node_factory>`
  to create loops in the graph.
  Please check out the examples section of this class.

- :py:class:`DOptional<deltalanguage.data_types.DOptional>` is used to make
  inputs optional, so the absence of input from them will not change the
  behavioural rules of the node.
  Please check out the examples section of this class.

  .. image:: ../../docs/figs/wiring.png
    :width: 600

Python Simulator specifics
^^^^^^^^^^^^^^^^^^^^^^^^^^

This section adds a few extra points on the Python Simulator
:py:class:`DeltaPySimulator<deltalanguage.runtime.DeltaPySimulator>` that
users should be aware:

- `Constant Nodes <const_nodes.html>`_ (:download:`const_nodes.ipynb`)
  talks about caching of node results for reducing the
  computation load on a runtime.

- `No input blocking <no_input_blocking.html>`_
  (:download:`no_input_blocking.ipynb`) gives details about a
  common issue when a node has only optional inputs.

Tips and tricks
^^^^^^^^^^^^^^^

This section has an unsorted collection of tutorial on various topics

- `Global constant environment <global_const_use.html>`_
  (:download:`global_const_use.ipynb`) can be used by nodes.
  This is the main mechanism of providing environment parameters to
  the graph at the running stage.

- `Non-deterministic state history <state_history.html>`_
  (:download:`state_history.ipynb`) may be a significant issue
  while working with Deltaflow language.

- `Logging and tracing within Deltaflow <logging.html>`_
  (:download:`logging.ipynb`) covers
  how to log computation within different aspects of a Deltaflow graph.
  Additionally we show how the external tool
  `VizTracer <https://github.com/gaogaotiantian/viztracer>`_ can be used to
  produce performance reports like this one
  (:download:`viztracer_example.html`)
  that visualize the multithreaded simulation of the graph.

.. TODO::
  Add a tutorial on node testing in a testbench graph.
  It means that a node of interest can be places in a new graph where inputs
  are generated via interactive nodes or helper nodes from primitives.
  Then the node's outputs are gathered and used to analyse it's performance.
  In a sense this is an analogue of unit testing for nodes.

Deltaflow and FPGA
------------------

One of the main purposes of the Deltaflow language is to provide an
infrastructure to porting quantum algorithms on hardware, more specifically
a heterogeneous hybrid computing system.
"Hybrid" implies that both central (CPU) and quantum processing units (QPU)
are used.

One of the key requirements for accessing QPU is the lowest possible latency,
which can be accessed only via FPGA.
This section describes how FPGA programming is handled in Deltaflow.

VLSI design for software developers 101
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This is intended to provide a few basic elements of FPGA and VLSI
(Very-Large Scale Integrated circuits) design to software developers.

FPGA stands for Field Programmable Gate Array and is often referred as 
Programmable Logic.
FPGAs are composed by hundreds of thousands or millions
of Programmable Logic elements, organised in a regular matrix structure, 
and connected through reconfigurable connections.
Each Logic element is composed 
of at least a configurable Logic Gate (Look-Up-Tables) and a single bit 
memorization element, called Flip-Flop
(`I <https://en.wikipedia.org/wiki/Flip-flop_(electronics)#D_flip-flop>`_ and
`II <https://learnabout-electronics.org/Digital/dig53.php>`_)

Similarly to
`ASIC <https://en.wikipedia.org/wiki/Application-specific_integrated_circuit>`_,
FPGA logic is described through dedicated programming 
languages, commonly referred as HDLs (Hardware Description Languages):

- VHDL
- Verilog
- System Verilog

Circuit descriptions in HDL are converted to 
a netlist of logic gates, Flip-Flops and interconnections, through the 
so-called `Synthesis <https://en.wikipedia.org/wiki/Logic_synthesis>`_ 
process, which is performed by specialised EDA (Electronic Design Automation) 
tools.
After the synthesis, the
`Place-and-Root <https://en.wikipedia.org/wiki/Place_and_route>`_ 
phase matches the elements in the netlist with physical resources on the FPGA, 
optimising the location of logic elements and interconnections according 
user specified optimization targets.

There are few critical aspects to understand about VLSI and FPGA design:

- Synchronous design and clocking
- Custom width binary logic
- The difference between synchronous and combinational logic
- Static Timing Analysis

After a short discussion about each of these topics, links to additional 
free online documentation are provided. 

Synthesis tools can efficiently manage only
`synchronous designs <https://en.wikipedia.org/wiki/Synchronous_circuit>`_, 
with the state of memory elements being synchronized to a clock signal.
Crossing between different clock domains is managed through dedicated
re-synchronization logic. 

Memory elements (D-Flip-Flops and embedded RAM) are often referred as
synchronous logic, as opposed to combinational logic, i.e.: logic gates.
Synchronous elements has an internal state which is updated only when there
is either a rising or a falling clock edge.
Combinational logic is stateless, with  the output value being a pure
function of its inputs.
Any change in the input values is propagated to the outputs, within
the propagation time.
The propagation time defines the speed of the logic.
The distinction between synchronous and combinational logic is important 
because, to operate synchronously, the signal propagation times between every 
synchronous element in the same clock domain must be less than clock period,
minus the setup and hold times.
Setup and hold times define the minimum amount of time a signal must be
stable respectively before and after a rising edge clock (for a positive
edge D-Flip-Flop), to prevent the memory element to enter in a `metastable 
state <https://en.wikipedia.org/wiki/Metastability_(electronics)>`_.  

Timing constraints over all the clock regions are automatically checked
through a process called `Static Timing Analysis
<https://en.wikipedia.org/wiki/Static_timing_analysis>`_ (STA).
STA is performed by an apposite tool that generates an estimate of the
maximum clock frequency for each clock region. The clock frequency defines 
the processing speed, cause the amount of time necessary to complete a given 
operation (latency) is given by the the number of required clock cycles, 
multiplied by the clock period. 
The STA tool often operates in conjunction to the Synthesis and Place and
Route tool, to achieve user specified optimization targets (speed, area 
or power dissipation).
Meeting the timing constraints depend on several factors:

- Primarily the way the logic is described in HDL, with the resulting combinational 
  logic propagation time. This is essentially proportional to the number of cascaded 
  logic gates on the most critical path between synchronous elements.

- The physical interconnection length across the path.

- The `clock skew <https://en.wikipedia.org/wiki/Clock_skew>`_.

- The speed of the underlying logic and interconnections. This is a purely 
  technological factor which depends on the FPGA device family and speed-grade.

The most critical aspect to understand when describing a VLSI (FPGA or ASIC)
in HDL, is not the language, which is not too dissimilar from other high
level languages, such as C or C++, but the fact that the programmer needs
to describe a circuit made of custom logic elements, identify which logic
elements are present, how they are interconnected, how they exchange signals
at every clock cycle, in parallel. 
Custom logic allows to achieve processing speed impossible to achieve with
simple CPUs, because several parallel resources can be allocated to perform 
tasks. This however comes at cost of a higher programming complexity, if 
compared to normal software: 
with normal software the programmer’s task is to define instructions to be 
sequentially run on a processor composed of a fixed amount of resources, which 
is specific to the propessor architecture, and a well defined instruction set.
Because of the fix instruction set and processor resources, compilers can
easily derive the optimal sequence of instructions to be executed, starting
from any high-level programming language.

Unfortunately, VLSI synthesis tools are not able to derive efficient circuit 
descriptions from high-level, behavioural HDL code. Efficient synthesis is only 
possible when the designer adopts a description level referred as 
`Register Transfer Level
<https://en.wikipedia.org/wiki/Register-transfer_level>`_. 
RTL design can be learned in a reasonable amount of time, although full mastery
requires more effort than normal software design. With sufficient practice, a 
VLSI designer develops a natural understanding of what kind of HDL descriptions 
can be properly synthesised with a certain optimization target or trade-off in 
mind: maximum clock frequency, minimal resource optimaization, power consumption. 
Code portability, scalability and design for testing should also be taken in 
consideration.   

When describing custom logic at RTL level, all the operations (arithmetical, 
logical) are defined on binary operands, whose bit-width must be defined using 
the minimum data bit-width, to save resources, avoid useless critical paths 
and power consumption. 

Control logic is often designed using either
`Moore <https://en.wikipedia.org/wiki/Moore_machine>`_ or
`Mealy <https://en.wikipedia.org/wiki/Mealy_machine>`_ Finite State Machines. 

A general tutorial on FPGA design can be found
`here <https://www.nandland.com/articles/fpga-101-fpgas-for-beginners.html>`_. 

Describing programmable logic with Deltaflow
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Deltaflow allows to describe FPGA logic in python using a template language
called `Migen <https://m-labs.hk/gateware/migen>`_.
Migen code can be simulated, with the resulting timing diagrams exportable to
a VCD file for visualization.
Migen code is translated into synthesizable verilog, for further simulation
or synthesis.

This external
`tutorial <http://blog.lambdaconcept.com/doku.php?id=migen:tutorial>`__
is a good starting point for learning migen.
After that learn how to use Migen with Deltaflow:

- `Migen Nodes <migen_node.html>`_ (:download:`migen_node.ipynb`) 
  contains introductory examples on how migen is integrated in
  the Deltaflow language via
  :py:class:`MigenNodeTemplate <deltalanguage.wiring.MigenNodeTemplate>`.

  .. image:: ../../docs/figs/migen_node_template.png
    :width: 600

- :download:`migen_hardware_examples.py` contains a more realistic example with
  migen
  

Interfacing with Deltasimulator and Deltaruntime
------------------------------------------------

Whereas the Deltaflow language provides the infrastructure for defining
and debugging of :py:class:`DeltaGraph<deltalanguage.wiring.DeltaGraph>`,
the actual evaluation happens on either Deltasimulator or Deltaruntime.

- The interface between them is platform agnostic and implemented via a pair of
  helper functions
  :py:func:`serialize_graph<deltalanguage.runtime.serialize_graph>` and
  :py:func:`deserialize_graph<deltalanguage.runtime.deserialize_graph>`.
  This idea is highlighted in this example :download:`serialisation_example.py`. 

- Use
  :py:func:`template_node_factory<deltalanguage.wiring.template_node_factory>`
  to create templates for nodes that can be provided after
  deserialization.
  Please check out the examples section of this class.
